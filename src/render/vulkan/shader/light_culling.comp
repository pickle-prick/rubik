#version 450

layout(local_size_x=8, local_size_y=8, local_size_z=1) in;

/////////////////////////////////////////////////////////////////////////////////////////
// basic types

struct Plane
{
    vec3 N; // Plane normal
    float d; // Distance to origin
};

// the back and/or front planes can be computed from min/max depth values from fragments within this group 
struct Frustum
{
    Plane planes[6]; // left,right,top,bottom frustum planes
};

struct Sphere
{
    vec3 c; // center point
    float r; // raidus
};

struct Cone
{
    vec3 T; // cone tip point pos
    float h; // height of the cone
    vec3 d; // direction of the cone
    float r; // bottom radius of the cone
};

struct Light
{
    // 0: point light
    // 1: spot light
    // 2: direction light
    uint kind;
    float radius;
    vec3 p;
    vec3 dir;
};

/////////////////////////////////////////////////////////////////////////////////////////
//~ input/output

/////////////////////////////////////////////////////////////////////////////////////////
//- input
layout(std140, set=0, binding=0) uniform UBO
{
    mat4 proj_inv;
    uint light_count;
} ubo;

// global lights
layout(std140, set=1, binding=0) buffer Lights
{
    Light array[];
} lights;

layout(set=2, binding=0) uniform sampler2D depth_texture;

// tiles
layout(std140, set=3, binding=0) buffer Tiles
{
    Frustum frustums[];
} tiles;

/////////////////////////////////////////////////////////////////////////////////////////
//- output

// TODO(XXX): we need two lists, one for opaque geometry, one for transparent geometry
// global light indices
layout(std140, set=4, binding=0) buffer LightIndices
{
    uint indices[];
} light_indices;

// TODO(XXX): we need two lists, one for opaque geometry, one for transparent geometry
// tile lights (2D grid)
layout(std140, set=5, binding=0) buffer TileLights
{
    uint offset;
    uint light_count;
} tile_lights;

/////////////////////////////////////////////////////////////////////////////////////////
//~ Group shared variables

shared uint min_depth_u;
shared uint max_depth_u;

shared Frustum group_frustum;

// we also need to declear group-shared variables to create the temporary light lists
shared uint light_count; // keep track of the number of lights that are intersecting the current tile frustum
// the offset into the global light index list
// this index wil be written to the light grid and is used as the starting offset when copying the local light index list to global light index list 
shared uint light_index_start_offset;
// this list will allow us to store as many as 1024 lights in a single tile
// this maximum value will almost never be reached (at least it shouldn't be)
shared uint light_list[1024];

/////////////////////////////////////////////////////////////////////////////////////////
// frustum culling
// 1. Frustum-Sphere culling for point lights
// 2. Frustum-Cone culling for spot lights

// check to see if a sphere is fully behind (inside the negative halfspace of) a plane
// Source: Real-time collision detection, Christer Ericson (2005)
bool sphere_inside_plane(Sphere sphere, Plane plane)
{
    return (plane.d - dot(plane.N, sphere.c)) > sphere.r;
}

bool sphere_inside_frustum(Sphere sphere, Frustum frustum, float z_near, float z_far)
{
    bool result = true;

    // check near/fear plane
    if((sphere.c.z+sphere.r) > z_far || (sphere.c.z-sphere.r) < z_near)
    {
        result = false;
    }

    for(int i = 0; i < 4 && result; i++)
    {
        if(!sphere_inside_plane(sphere, frustum.planes[i]))
        {
            result = false;
        }
    }
    return result;
}

vec3 clip_to_view(vec4 p, mat4 proj_inv)
{
    vec4 ret = proj_inv * p;
    return ret.xyz/ret.w;
}

void push_light(uint light_idx)
{
    // index into the visible lights array
    uint index = atomicAdd(light_count, 1);
    // TODO(XXX): not sure if this is needed or not
    memoryBarrierBuffer();

    if(index < 1024)
    {
        light_list[index] = light_idx;
    }
}

void main()
{
    const uint group_thread_count = gl_WorkGroupSize.x*gl_WorkGroupSize.y;

    // depth sampling
    ivec2 depth_tex_coord = ivec2(gl_GlobalInvocationID.xy);
    float depth_f = texelFetch(depth_texture, depth_tex_coord, 0).r;
    uint depth_u = floatBitsToUint(depth_f);

    // first thread in group initializes shared memory
    if(gl_LocalInvocationIndex == 0)
    {
        min_depth_u = 0xffffffffu;
        max_depth_u = 0u;
        light_count = 0u;

        // calculate frustum index
        uint frustum_idx = (gl_WorkGroupID.y*group_thread_count) + gl_WorkGroupID.x;
        group_frustum = tiles.frustums[frustum_idx];
    }

    // Memory synchronization for group-shared variables
    barrier();
    memoryBarrierShared();

    // atomic min/max operations using integer representation
    atomicMin(min_depth_u, depth_u);
    atomicMax(max_depth_u, depth_u);

    // second synchronization barrier 
    barrier();
    memoryBarrierShared();

    // uint to float
    float min_depth_f = uintBitsToFloat(min_depth_u);
    float max_depth_f = uintBitsToFloat(max_depth_u);

    // depth to view space conversion
    float min_depth_vs = clip_to_view(vec4(0,0,min_depth_f,1), ubo.proj_inv).z;
    float max_depth_vs = clip_to_view(vec4(0,0,max_depth_f,1), ubo.proj_inv).z;
    // float near_clip_vs = clip_to_view(vec4(0,0,0,1), ubo.proj_inv).z;

    // clipping plane for minimum depth value
    // used for testing lights within the bounds of opaque(should it be transparent?) objects
    // TODO(XXX): not sure if we need this or not
    // Plane near_plane = {vec3(0,0,1), near_ckip_vs};

    // lights culling
    // each thread in a group will cull 1 light until all lights are culled
    for(uint i = gl_LocalInvocationIndex; i < ubo.light_count ; i+=group_thread_count)
    {
        // count every direction light
        // for point/spot light, we use frustum sphere/cone intersection
        Light l = lights.array[i];

        switch(l.kind)
        {
            case 0:
            {
                Sphere sphere = {l.p, l.radius};
                if(sphere_inside_frustum(sphere, group_frustum, min_depth_vs, max_depth_vs)) 
                {
                    lights.array[light_count++] = l;
                }
            }break;
            case 1:
            {
                // TODO(XXX): not implemented
                // cone
            }break;
            case 2:
            {
                lights.array[light_count++] = l;
            }break;
        }
    }
}
